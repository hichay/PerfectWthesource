// node_modules/@neodrag/svelte/dist/index.js
function t(t2, e2, n2, o2) {
  var r2, i2 = (r2 = o2) == null || typeof r2 == "number" || typeof r2 == "boolean" ? o2 : n2(o2), a2 = e2.get(i2);
  return a2 === void 0 && (a2 = t2.call(this, o2), e2.set(i2, a2)), a2;
}
function e(t2, e2, n2) {
  var o2 = Array.prototype.slice.call(arguments, 3), r2 = n2(o2), i2 = e2.get(r2);
  return i2 === void 0 && (i2 = t2.apply(this, o2), e2.set(r2, i2)), i2;
}
function n(n2, o2) {
  return function(t2, e2, n3, o3, r2) {
    return n3.bind(e2, t2, o3, r2);
  }(n2, this, n2.length === 1 ? t : e, o2.cache.create(), o2.serializer);
}
var o = JSON.stringify;
function r() {
  this.cache = /* @__PURE__ */ Object.create(null);
}
r.prototype.has = function(t2) {
  return t2 in this.cache;
}, r.prototype.get = function(t2) {
  return this.cache[t2];
}, r.prototype.set = function(t2, e2) {
  this.cache[t2] = e2;
};
var i = { create: function() {
  return new r();
} };
var a = (t2, e2 = {}) => {
  var _a2, _b2;
  let { bounds: n2, axis: o2 = "both", gpuAcceleration: r2 = true, applyUserSelectHack: i2 = true, disabled: a2 = false, ignoreMultitouch: d2 = false, grid: h2, position: f2, cancel: g2, handle: m, defaultClass: y = "neodrag", defaultClassDragging: b = "neodrag-dragging", defaultClassDragged: w = "neodrag-dragged", defaultPosition: v = { x: 0, y: 0 }, onDragStart: E, onDrag: x, onDragEnd: C } = e2;
  const S = new Promise(requestAnimationFrame);
  let M, D, N = false, A = 0, R = 0, B = 0, H = 0, L = 0, q = 0, { x: T, y: $ } = f2 ? { x: (_a2 = f2 == null ? void 0 : f2.x) != null ? _a2 : 0, y: (_b2 = f2 == null ? void 0 : f2.y) != null ? _b2 : 0 } : v;
  p(T, $, t2, r2);
  let z, X, Y, j, k = "", O = !!f2;
  const P = document.body.style, U = t2.classList, W = (e3, n3) => {
    const o3 = { offsetX: A, offsetY: R, domRect: t2.getBoundingClientRect() };
    t2.dispatchEvent(new CustomEvent(e3, { detail: o3 })), n3 == null ? void 0 : n3(o3);
  };
  const F = addEventListener;
  F("touchstart", G, false), F("touchend", I, false), F("touchmove", K, false), F("mousedown", G, false), F("mouseup", I, false), F("mousemove", K, false), t2.style.touchAction = "none";
  const J = () => {
    let e3 = t2.offsetWidth / X.width;
    return isNaN(e3) && (e3 = 1), e3;
  };
  function G(e3) {
    if (a2)
      return;
    if (d2 && e3.type === "touchstart" && e3.touches.length > 1)
      return;
    if (U.add(y), Y = function(t3, e4) {
      if (!t3)
        return e4;
      if (t3 instanceof HTMLElement)
        return t3;
      const n3 = e4.querySelector(t3);
      if (n3 === null)
        throw new Error("Selector passed for `handle` option should be child of the element on which the action is applied");
      return n3;
    }(m, t2), j = function(t3, e4) {
      if (!t3)
        return;
      if (t3 instanceof HTMLElement)
        return t3;
      const n3 = e4.querySelector(t3);
      if (n3 === null)
        throw new Error("Selector passed for `cancel` option should be child of the element on which the action is applied");
      return n3;
    }(g2, t2), M = /(both|x)/.test(o2), D = /(both|y)/.test(o2), n2 !== void 0 && (z = function(t3, e4) {
      if (t3 instanceof HTMLElement)
        return t3.getBoundingClientRect();
      if (typeof t3 == "object") {
        const { top: e5 = 0, left: n4 = 0, right: o3 = 0, bottom: r4 = 0 } = t3;
        return { top: e5, right: window.innerWidth - o3, bottom: window.innerHeight - r4, left: n4 };
      }
      if (t3 === "parent")
        return e4.parentNode.getBoundingClientRect();
      const n3 = document.querySelector(t3);
      if (n3 === null)
        throw new Error("The selector provided for bound doesn't exists in the document.");
      return n3.getBoundingClientRect();
    }(n2, t2)), X = t2.getBoundingClientRect(), l(m) && l(g2) && m === g2)
      throw new Error("`handle` selector can't be same as `cancel` selector");
    if (j == null ? void 0 : j.contains(Y))
      throw new Error("Element being dragged can't be a child of the element on which `cancel` is applied");
    if (Y.contains(e3.target) && !(j == null ? void 0 : j.contains(e3.target)) && (N = true), !N)
      return;
    i2 && (k = P.userSelect, P.userSelect = "none"), W("neodrag:start", E);
    const { clientX: r3, clientY: s2 } = c(e3) ? e3.touches[0] : e3, u2 = J();
    M && (B = r3 - T / u2), D && (H = s2 - $ / u2), z && (L = r3 - X.left, q = s2 - X.top);
  }
  function I() {
    N && (U.remove(b), U.add(w), i2 && (P.userSelect = k), W("neodrag:end", C), M && (B = A), M && (H = R), N = false);
  }
  function K(e3) {
    if (!N)
      return;
    U.add(b), e3.preventDefault(), X = t2.getBoundingClientRect();
    const { clientX: n3, clientY: o3 } = c(e3) ? e3.touches[0] : e3;
    let i3 = n3, a3 = o3;
    const l2 = J();
    if (z) {
      const t3 = { left: z.left + L, top: z.top + q, right: z.right + L - X.width, bottom: z.bottom + q - X.height };
      i3 = s(i3, t3.left, t3.right), a3 = s(a3, t3.top, t3.bottom);
    }
    if (Array.isArray(h2)) {
      let [t3, e4] = h2;
      if (isNaN(+t3) || t3 < 0)
        throw new Error("1st argument of `grid` must be a valid positive number");
      if (isNaN(+e4) || e4 < 0)
        throw new Error("2nd argument of `grid` must be a valid positive number");
      let n4 = i3 - B, o4 = a3 - H;
      [n4, o4] = u([Math.floor(t3 / l2), Math.floor(e4 / l2)], n4, o4), i3 = B + n4, a3 = H + o4;
    }
    M && (A = (i3 - B) * l2), D && (R = (a3 - H) * l2), T = A, $ = R, W("neodrag", x), S.then(() => p(A, R, t2, r2));
  }
  return { destroy: () => {
    const t3 = removeEventListener;
    t3("touchstart", G, false), t3("touchend", I, false), t3("touchmove", K, false), t3("mousedown", G, false), t3("mouseup", I, false), t3("mousemove", K, false);
  }, update: (e3) => {
    var _a3, _b3, _c2, _d, _e, _f, _g, _h, _i, _j, _k;
    o2 = e3.axis || "both", a2 = (_a3 = e3.disabled) != null ? _a3 : false, d2 = (_b3 = e3.ignoreMultitouch) != null ? _b3 : false, m = e3.handle, n2 = e3.bounds, g2 = e3.cancel, i2 = (_c2 = e3.applyUserSelectHack) != null ? _c2 : true, h2 = e3.grid, r2 = (_d = e3.gpuAcceleration) != null ? _d : true;
    const c2 = U.contains(w);
    U.remove(y, w), y = (_e = e3.defaultClass) != null ? _e : "neodrag", b = (_f = e3.defaultClassDragging) != null ? _f : "neodrag-dragging", w = (_g = e3.defaultClassDragged) != null ? _g : "neodrag-dragged", U.add(y), c2 && U.add(w), O && (T = A = (_i = (_h = e3.position) == null ? void 0 : _h.x) != null ? _i : A, $ = R = (_k = (_j = e3.position) == null ? void 0 : _j.y) != null ? _k : R, S.then(() => p(A, R, t2, r2)));
  } };
};
var c = (t2) => {
  var _a2;
  return !!((_a2 = t2.touches) == null ? void 0 : _a2.length);
};
var s = (t2, e2, n2) => Math.min(Math.max(t2, e2), n2);
var l = (t2) => typeof t2 == "string";
var _a, _b, _c;
var u = (d = ([t2, e2], n2, o2) => {
  const r2 = (t3, e3) => Math.round(t3 / e3) * e3;
  return [r2(n2, t2), r2(o2, e2)];
}, f = (_a = h == null ? void 0 : h.cache) != null ? _a : i, g = (_b = h == null ? void 0 : h.serializer) != null ? _b : o, ((_c = h == null ? void 0 : h.strategy) != null ? _c : n)(d, { cache: f, serializer: g }));
var d;
var h;
var f;
var g;
function p(t2, e2, n2, o2) {
  n2.style.transform = o2 ? `translate3d(${+t2}px, ${+e2}px, 0)` : `translate(${+t2}px, ${+e2}px)`;
}
export {
  a as draggable
};
//# sourceMappingURL=@neodrag_svelte.js.map
